Антошка, [2/18/2026 12:01 AM]
## Описание протокола для обмена данными и аутентификации на основе RSA

### 1. Назначение протокола
Разработанный протокол предназначен для установления защищенного соединения между двумя сторонами (Алисой и Бобом) с обеспечением конфиденциальности передаваемых сообщений, их целостности, а также двусторонней аутентификации участников. Протокол реализует гибридный подход, сочетающий асимметричную криптографию RSA для аутентификации и безопасной передачи ключей и симметричное шифрование AES для защиты непосредственно передаваемых сообщений.

### 2. Участники протокола
В протоколе участвуют две стороны:
- Алиса — инициатор соединения (клиент), которая первой устанавливает связь
- Боб — responder (сервер), который ожидает входящего подключения

Также в модели присутствует потенциальный злоумышленник Меллори, который может пытаться перехватывать или модифицировать сообщения.

### 3. Предварительный этап (подготовка ключей)
До начала работы протокола каждый участник выполняет генерацию ключевой пары RSA с длиной ключа 2048 бит. В результате создаются два файла:
- Приватный ключ (например, alice_private.pem) — хранится в секрете у владельца
- Публичный ключ (например, alice_public.pem) — предназначен для передачи собеседнику

Затем стороны обмениваются публичными ключами по любому доступному каналу связи (электронная почта, мессенджер, флеш-накопитель). Полученный от собеседника публичный ключ сохраняется под именем peer_public.pem. Этот этап выполняется однократно и является критическим с точки зрения безопасности — если злоумышленник сможет подменить публичные ключи на этапе обмена, он сможет реализовать атаку "человек посередине".

### 4. Этап установки соединения
Боб запускает программу в режиме сервера и начинает ожидать подключение на определенном порту (по умолчанию 12345). Алиса запускает программу в режиме клиента и подключается к IP-адресу Боба. После установления TCP-соединения начинается выполнение криптографического протокола.

### 5. Этап обмена публичными ключами
Первым действием Алиса отправляет Бобу свой публичный ключ в формате PEM. Боб принимает этот ключ и загружает его как публичный ключ собеседника. Затем Боб отправляет Алисе свой публичный ключ. Таким образом, после завершения этого этапа обе стороны имеют актуальные публичные ключи друг друга, даже если на предварительном этапе они не обменивались ключами (в данной реализации протокол поддерживает оба варианта).

### 6. Этап двусторонней аутентификации
Для подтверждения подлинности сторон используется механизм цифровых подписей на основе RSA. Процесс аутентификации происходит следующим образом:

Алиса генерирует случайное число (nonce) длиной 16 байт. Это число используется однократно и служит для защиты от атак повтора. Алиса создает цифровую подпись этого случайного числа с помощью своего приватного ключа и отправляет Бобу пару: само случайное число и его подпись.

Боб, получив сообщение, проверяет подпись, используя публичный ключ Алисы. Если подпись корректна, Боб убеждается, что сообщение действительно отправлено Алисой, а не злоумышленником. После этого Боб аналогичным образом генерирует свое случайное число, подписывает его своим приватным ключом и отправляет Алисе.

Алиса проверяет подпись Боба, завершая тем самым двустороннюю аутентификацию. Важно отметить, что использование разных случайных чисел в каждом сеансе исключает возможность успешного повторного использования записанных ранее сообщений злоумышленником.

### 7. Этап генерации и передачи сеансового ключа
После успешной аутентификации необходимо создать общий секретный ключ для симметричного шифрования, так как шифрование каждого сообщения асимметричным алгоритмом RSA было бы слишком медленным для интерактивного общения.

Алиса генерирует случайный сеансовый ключ длиной 32 байта (256 бит), который будет использоваться для шифрования всех последующих сообщений алгоритмом AES. Этот ключ необходимо передать Бобу, но передача его в открытом виде недопустима.

Алиса шифрует сгенерированный сеансовый ключ публичным ключом Боба, используя алгоритм RSA-OAEP. Только Боб, владеющий соответствующим приватным ключом, сможет расшифровать это сообщение. Для дополнительной защиты и подтверждения авторства Алиса также подписывает зашифрованный ключ своим приватным ключом.

Алиса отправляет Бобу зашифрованный ключ вместе с подписью. Боб проверяет подпись, убеждаясь, что ключ отправлен именно Алисой, а не злоумышленником, и затем расшифровывает сеансовый ключ своим приватным ключом. После успешного получения ключа Боб отправляет Алисе подтверждение "OK".

С этого момента обе стороны владеют общим сеансовым ключом, который неизвестен никому постороннему.

### 8. Этап защищенного обмена сообщениями
После установки сеансового ключа начинается основной обмен сообщениями. Каждое сообщение шифруется алгоритмом AES-256 в режиме GCM. Этот режим обеспечивает не только конфиденциальность, но и аутентификацию (целостность) сообщения.

При шифровании каждого сообщения генерируется новый случайный вектор инициализации (IV) длиной 12 байт. Это гарантирует, что даже одинаковые сообщения будут выглядеть по-разному в зашифрованном виде. К зашифрованному тексту добавляется аутентификационная метка (tag) длиной 16 байт, которая позволяет получателю проверить, не было ли сообщение изменено при передаче.

Отправитель формирует сообщение, объединяя вектор инициализации, аутентификационную метку и зашифрованный текст, и отправляет его получателю. Получатель разделяет полученные данные, проверяет целостность сообщения по аутентификационной метке и расшифровывает его.

Обмен сообщениями происходит в асинхронном режиме: выделенный поток постоянно ожидает входящие сообщения и выводит их на экран, в то время как основной поток позволяет пользователю вводить и отправлять свои сообщения.

### 9. Этап завершения сеанса
Когда один из участников хочет завершить общение, он вводит команду "exit". Программа шифрует специальное служебное сообщение "EXIT" с помощью сеансового ключа и отправляет его собеседнику. Получив это сообщение, другая сторона выводит уведомление о выходе собеседника и завершает работу. Соединение закрывается, сеансовый ключ уничтожается.

### 10. Обеспечиваемые свойства безопасности

Аутентификация сторон достигается за счет проверки цифровых подписей под случайными числами. Только владелец соответствующего приватного ключа может создать корректную подпись, которую можно проверить публичным ключом.

Конфиденциальность сеансового ключа обеспечивается его шифрованием публичным ключом получателя. Расшифровать его может только владелец соответствующего приватного ключа.

Конфиденциальность сообщений достигается шифрованием AES-256, который считается криптостойким алгоритмом и используется в большинстве современных защищенных протоколов.

Целостность сообщений обеспечивается режимом GCM, который создает аутентификационную метку для каждого сообщения. Любое изменение сообщения при передазе будет обнаружено при проверке.

Защита от атак повтора реализуется через использование уникальных случайных чисел (nonce) на этапе аутентификации. Даже если злоумышленник запишет сообщения легального сеанса, он не сможет использовать их повторно, так как в новом сеансе будут использоваться другие случайные числа.

Защита от атак типа "человек посередине" обеспечивается двусторонней аутентификацией. Если злоумышленник попытается подменить ключи или сообщения, его подпись не будет соответствовать публичному ключу легального участника, и аутентификация не будет пройдена.

Совершенная прямая секретность (частичная) обеспечивается генерацией нового сеансового ключа для каждого соединения. Даже если долговременный приватный ключ одного из участников будет скомпрометирован в будущем, это не позволит расшифровать ранее перехваченные сеансы, так как для их расшифровки нужен сеансовый ключ, который не хранится после завершения сеанса.

### 11. Особенности программной реализации
Программа написана на языке Python с использованием библиотеки cryptography. Сетевое взаимодействие реализовано через сокеты TCP. Для обеспечения одновременного приема и отправки сообщений используется многопоточность. Форматирование данных выполняется с помощью JSON, что обеспечивает удобство упаковки и распаковки структурированных сообщений.

Все передаваемые по сети данные предваряются 4-байтовым префиксом, содержащим длину сообщения. Это позволяет точно определять границы сообщений в непрерывном потоке данных.

### 12. Устойчивость к известным атакам
Разработанный протокол демонстрирует устойчивость к основным видам атак на криптографические протоколы:

- Replay attack — предотвращается использованием случайных nonce
- Man-in-the-Middle — предотвращается двусторонней аутентификацией
- Impersonation — невозможна без знания приватного ключа
- Dictionary attack — защита обеспечивается использованием криптостойких ключей
- Known key attack — каждый сеанс использует новый ключ

Таким образом, разработанный протокол обеспечивает надежную защиту передаваемых сообщений и может использоваться для конфиденциального общения в незащищенной среде.