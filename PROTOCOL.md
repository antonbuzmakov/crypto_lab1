# ПОЛНЫЙ КРИПТОГРАФИЧЕСКИЙ ПРОТОКОЛ
## Защищенный чат на основе RSA и AES

---

## УЧАСТНИКИ
- **Боб** — сервер (отвечающий, слушает на порту 12345)
- **Алиса** — клиент (инициатор, подключается к Бобу)

---

## OVERVIEW: КРИПТОГРАФИЧЕСКАЯ СХЕМА ПРОТОКОЛА

```
АЛИСА (Инициатор/Клиент)              ⟷           БОБ (Ответчик/Сервер)

Этап 1: Локальная генерация
  (RSA-2048 KeyGen)                                (RSA-2048 KeyGen)
  (p, q, n, e, d)                                  (p, q, n, e, d)
  ↓                                                ↓
  (alice_private.pem)                              (bob_private.pem)
  (alice_public.pem)                               (bob_public.pem)

Этап 2: TCP handshake
  ──────────→ Listening 0.0.0.0:12345
  ←──────────
  (TCP SYN/SYN-ACK/ACK)

Этап 3: Обмен публичными ключами
  alice_public.pem (294 B)
  ──────────────────────────────────→
                                    ↓ (Load & Store)
                                    (n_alice, e_alice)

  ←─────────────────────────────────── bob_public.pem (294B)
  ↓ (Load & Store)
  (n_bob, e_bob)

Этап 4: Взаимная аутентификация (RSA-PSS)
  nonce_alice = random(16)
  σ_alice = Sign_RSA-PSS(nonce_alice, d_alice)
  JSON: {nonce, σ}
  ──────────────────────────────────→
                                    ↓ (Verify_RSA-PSS)
                                    Assert Signature(d_alice) ✓

                                    nonce_bob = random(16)
                                    σ_bob = Sign_RSA-PSS(nonce_bob, d_bob)
                                    JSON: {nonce, σ}
  ←──────────────────────────────────
  ↓ (Verify_RSA-PSS)
  Assert Signature(d_bob) ✓

Этап 5: Согласование сессионного ключа AES-256
  K_session = random(32)
  C_K = RSA-OAEP_Encrypt(K_session, (n_bob, e_bob))
  σ_K = Sign_RSA-PSS(C_K, d_alice)
  JSON: {encrypted_key: C_K, signature: σ_K}
  ──────────────────────────────────→
                                    ↓ (Verify_RSA-PSS(σ_K))
                                    ✓ Signature valid from Alice
                                    ↓ (RSA-OAEP_Decrypt)
                                    K_session = Decrypt(C_K, d_bob)
                                    ↓ (Store in memory)

  ←─────────────────────────────────── "OK" Message

  *** ЗАЩИЩЁННЫЙ КАНАЛ УСТАНОВЛЕН ***
  *** Обе стороны обладают одинаковым K_session ***

Этап 6: Защищённое общение (AES-256-GCM)
  M = "Привет, Боб!" (11 bytes)
  IV = random(12)
  (C, T) = AES-256-GCM_Encrypt(M, K_session, IV)
  Payload = IV || T || C [12 + 16 + 11 = 39 bytes]
  ──────────────────────────────────→
                                    ↓ (Split: IV, T, C)
                                    M' = AES-256-GCM_Decrypt(...)
                                    ✓ T matches → Integrity OK
                                    ↓ Display: "Привет, Боб!"

                                    M = "Привет, Алиса!" (13 bytes)
                                    IV = random(12)
                                    (C, T) = AES-256-GCM_Encrypt(M, K_session, IV)
                                    Payload = IV || T || C
  ←──────────────────────────────────

  ... дальнейшее общение аналогично ...

Терминирование:
  EXIT_MSG (AES-256-GCM)
  ──────────────────────────────────→
                                    ↓ (Close)
  ←─────────────────────────────────── Close/EOF
  (TCP FIN/ACK)
```

---

## ЭТАП 1: ГЕНЕРАЦИЯ КЛЮЧЕВЫХ ПАР RSA

### Для Боба и Алисы (независимо, локально):

```
Параметры генерации:
  - Алгоритм: RSA (Rivest-Shamir-Adleman)
  - Размер модуля: 2048 бит (n = 2048)
  - Публичная экспонента: e = 65537 (0x10001)
  - Генератор: cryptography.hazmat.primitives.asymmetric.rsa
  - Backend: default_backend() (OpenSSL)
  - Формат хранения: PEM (Privacy Enhanced Mail), PKCS#8
```

**Боб генерирует:**
```
1. Выбираются два больших простых числа p и q (каждое ≈ 1024 бит)
2. Вычисляется модуль: n = p × q (2048 бит)
3. Вычисляется функция Эйлера: φ(n) = (p-1) × (q-1)
4. Выбирается публичная экспонента: e = 65537
5. Вычисляется приватная экспонента: d, такая что e×d ≡ 1 (mod φ(n))

Результат:
  - Боб_публичный_ключ = (n, e = 65537)
  - Боб_приватный_ключ = (n, d, p, q, dmp1, dmq1, iqmp)

Сохранение:
  - bob_public.pem  ← публичная часть в формате SubjectPublicKeyInfo
  - bob_private.pem ← приватная часть в формате PKCS#8 без шифрования
```

**Алиса генерирует идентично:**
```
Результат:
  - alice_public.pem  ← публичная часть
  - alice_private.pem ← приватная часть
```

---

## ЭТАП 2: УСТАНОВКА TCP СОЕДИНЕНИЯ

```
Боб                                        Алиса
 |                                           |
 |──────── слушает 0.0.0.0:12345 ────────────|
 |                                           |
 |                    подключение            |
 |←──────────────────────────────────────────|
 |  TCP SYN/SYN-ACK (трёхсторонний рукопожим)|
 |                                           |
 └────────────── TCP СОЕДИНЕНИЕ ─────────────┘
```

---

## ЭТАП 3: ОБМЕН ПУБЛИЧНЫМИ КЛЮЧАМИ RSA

### Шаг 3.1: Алиса → Боб (отправка публичного ключа Алисы)

```
Алиса отправляет:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  Публичный ключ Алисы (PEM формат)

  -----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...
  ...
  -----END PUBLIC KEY-----

  Примерный размер: ~294 байта
)

Содержимое публичного ключа:
  - модуль n (2048 бит) = произведение p×q
  - экспонента e = 65537
```

**На стороне Боба:**
```
Боб получает: alice_public.pem
Десериализация: PEM → объект PublicKey
Содержится: (n_alice, e_alice = 65537)
Хранит в памяти как: peer_public_key
```

### Шаг 3.2: Боб → Алиса (отправка публичного ключа Боба)

```
Боб отправляет:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  Публичный ключ Боба (PEM формат)

  -----BEGIN PUBLIC KEY-----
  MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A...
  ...
  -----END PUBLIC KEY-----

  Примерный размер: ~294 байта
)

Содержимое публичного ключа:
  - модуль n (2048 бит) = произведение p×q
  - экспонента e = 65537
```

**На стороне Алисы:**
```
Алиса получает: bob_public.pem
Десериализация: PEM → объект PublicKey
Содержится: (n_bob, e_bob = 65537)
Хранит в памяти как: peer_public_key
```

### Результат этапа:
```
Боб знает: (n_alice, e_alice)
Алиса знает: (n_bob, e_bob)
```

---

## ЭТАП 4: ДВУСТОРОННЯЯ АУТЕНТИФИКАЦИЯ (RSA-PSS подписи)

### Шаг 4.1: Алиса → Боб (nonce + подпись Алисы)

```
Алиса генерирует nonce:
(
  nonce_alice = os.urandom(16)
  Генератор: криптографический RNG
  Размер: 16 байт (128 бит)
  Пример: 0x 4f 2a c3 7e ...
)

Алиса подписывает nonce своим приватным ключом:
(
  АЛГОРИТМ RSA-PSS (Probabilistic Signature Scheme)

  Сырые данные: nonce_alice (16 байт)
    - Хэш-функция: SHA-256
    - MGF: MGF1(SHA-256)
    - Длина соли: максимальная
      (salt_length = len(hash_output) = 32 байта)
    - Подписание: использует d_alice

  Математика:
    1. hash = SHA256(nonce_alice)
    2. padded_msg = PSS_encode(hash)
    3. signature = padded_msg^d_alice mod n_alice

  Результат: signature_alice (256 байт)
)

Алиса отправляет JSON:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  {
    "nonce": "4f2ac37e...(hex 32 символа)",
    "signature": "a1b2c3d4...(hex 512 симв)"
  }

  Общий размер JSON: ~580 байт
)
```

**На стороне Боба (проверка подписи):**
```
Боб получает: {nonce="4f2ac37e...", signature="a1b2c3d4..."}

Проверка подписи Алисы:
(
  Данные: nonce_alice
  Подпись: signature_alice
  Публичный ключ: (n_alice, e_alice)

  Математика:
    1. decrypted = signature_alice^e_alice mod n
    2. hash_received = extract_hash(decrypted)
    3. hash_computed = SHA256(nonce_alice)
    4. Если hash_received == hash_computed ✓
       → подпись верна, это точно Алиса!
)

Результат: ✓ Алиса аутентифицирована
```

### Шаг 4.2: Боб → Алиса (nonce + подпись Боба)

```
Боб генерирует nonce:
(
  nonce_bob = os.urandom(16)
  Размер: 16 байт (128 бит)
)

Боб подписывает nonce своим приватным ключом (идентично):
(
  АЛГОРИТМ RSA-PSS (как на шаге 4.1)

  Сырые данные: nonce_bob (16 байт)
    - Хэш-функция: SHA-256
    - MGF: MGF1(SHA-256)
    - signature = padded_msg^d_bob mod n_bob

  Результат: signature_bob (256 байт)
)

Боб отправляет JSON:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  {
    "nonce": "7d3e4f1a...(hex 32 символа)",
    "signature": "b2c3d4e5...(hex 512 симв)"
  }
)
```

**На стороне Алисы (проверка подписи):**
```
Алиса получает подпись от Боба и проверяет её
используя публичный ключ Боба (идентично шагу 4.1)

Результат: ✓ Боб аутентифицирован
```

### Результат этапа:
```
✓ Боб подтвердил, что сообщение от настоящей Алисы
✓ Алиса подтвердила, что сообщение от настоящего Боба

Обе стороны уверены в подлинности друг друга
```

---

## ЭТАП 5: СОГЛАСОВАНИЕ СЕССИОННОГО КЛЮЧА AES-256

### Шаг 5.1: Алиса генерирует сессионный ключ

```
Алиса создаёт случайный сессионный ключ для AES-256:
(
  session_key_raw = os.urandom(32)

  Генератор: os.urandom() (системный криптографический RNG)
  Размер: 32 байта = 256 бит
  Пример: 0x a1 b2 c3 d4 e5 f6 g7...

  ВАЖНО: этот ключ остаётся СЕКРЕТНЫМ!
)
```

### Шаг 5.2: Алиса шифрует ключ публичным ключом Боба

```
Алиса использует публичный ключ Боба (который получила на этапе 3):

АЛГОРИТМ RSA-OAEP (Optimal Asymmetric Encryption Padding)
(
  Открытый текст: session_key_raw (32 байта)

  Параметры шифрования:
    - Публичный ключ: (n_bob, e_bob = 65537)
    - Хэш-функция: SHA-256
    - MGF: MGF1(SHA-256)
    - Label: None (нет дополнительного контекста)

  Математика шифрования:
    1. padded_msg = OAEP_encode(session_key, seed)
    2. ciphertext = padded_msg^e_bob mod n_bob

  Результат: encrypted_key (256 байт)
            (размер = 2048 бит / 8 = 256 байт)
)

ВАЖНО: Теперь только Боб может расшифровать этот ключ
       (он обладает приватной экспонентой d_bob)
```

### Шаг 5.3: Алиса подписывает зашифрованный ключ

```
Алиса подписывает зашифрованный ключ своей приватной подписью:
(
  АЛГОРИТМ RSA-PSS (как на этапе 4)

  Данные для подписи: encrypted_key (256 байт)
    - Хэш: SHA-256(encrypted_key)
    - Подписант: Алиса (приватный ключ)
    - Результат: key_signature (256 байт)

  Назначение подписи:
    - Подтверждение, что ключ от Алисы
    - Защита от подделки зашифрованного ключа
)
```

### Шаг 5.4: Алиса → Боб (отправка зашифрованного ключа + подпись)

```
Алиса отправляет JSON:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  {
    "encrypted_key": "3a4b5c...(hex 512 симв)",
    "signature": "f7e8d9...(hex 512 символов)"
  }

  Общий размер: примерно 1050 байт
)
```

### Шаг 5.5: Боб расшифровывает ключ

```
Боб получает: {encrypted_key, signature}

Проверка подписи:
(
  Данные: encrypted_key
  Подпись: signature от Алисы
  Публичный ключ: (n_alice, e_alice)

  Проверка: как на этапе 4 (RSA-PSS verify)

  Результат: ✓ Ключ точно от Алисы
)

Расшифровка ключа:
(
  АЛГОРИТМ RSA-OAEP (дешифрование)

  Зашифрованный ключ: encrypted_key
  Приватный ключ Боба: (n_bob, d_bob)

  Математика:
    1. decrypted = encrypted_key^d_bob mod n
    2. session_key = OAEP_decode(decrypted)

  Результат: session_key_raw (32 байта)
            (идентично тому, что создала Алиса)

  ВАЖНО: Теперь Боб знает сессионный ключ!
)
```

### Шаг 5.6: Боб → Алиса (подтверждение получения)

```
Боб отправляет подтверждение:
(
  Размер: 4 байта
  ────────────────
  "OK" (2 байта)
)

Это означает: ✓ сессионный ключ успешно получен и расшифрован
```

### Результат этапа:
```
Боб и Алиса обладают одинаковым сессионный ключ:
***─────────────────────────────────────────────***
*** session_key = 32 случайных байта (256 бит) ***
***─────────────────────────────────────────────***

Ключ хранится только в памяти, никогда не передавался открыто!
```

---

## ЭТАП 6: ЗАЩИЩЁННОЕ ОБЩЕНИЕ (AES-256-GCM)

### Способ передачи сообщения:

```
Алиса пишет сообщение: "Привет, Боб!"

АЛГОРИТМ AES-256-GCM (Galois/Counter Mode)
(
  Открытый текст: "Привет, Боб!" (11 байт)

  Параметры шифрования:
    - Сессионный ключ: session_key (32 байта)
    - IV (Initialization Vector):
      iv = os.urandom(12) (12 байт, 96 бит)
      Пример: 0x 3d 5a 9f 2b c1 e7 4f 1a ...
      ВАЖНО: уникальный для каждого сообщения
    - Режим: GCM (Galois/Counter Mode)
    - Аутентификация: встроенная в GCM

  Процесс:
    1. encryptor = AES(session_key, GCM(iv))
    2. ciphertext = encryptor.update(plaintext)
    3. ciphertext += encryptor.finalize()

  Выходные данные:
    - IV: 12 байт
    - AUTHENTICATION TAG: 16 байт
      (проверка целостности и подлинности)
    - CIPHERTEXT: длина зависит от сообщения

  Для "Привет, Боб!":
    - IV: 12 байт
    - Tag: 16 байт
    - Ciphertext: 11 байт
    Итого: 39 байт
)

Алиса → Боб отправляет:
(
  Размер: 4 байта (big-endian)
  ────────────────────────────
  IV (12 байт) +
  Tag (16 байт) +
  Ciphertext (11 байт)
  = 39 байт
)
```
 
### Боб расшифровывает сообщение:

```
Боб получает: [IV (12) + Tag (16) + Ciphertext (11)] 

АЛГОРИТМ AES-256-GCM (дешифрование)
(
  1. Отделяет компоненты:
     - IV = первые 12 байт
     - Tag = байты 12-27
     - Ciphertext = байты 28 и далее

  2. Создаёт дешифратор:
     decryptor = AES(session_key, GCM(IV, Tag))

  3. Расшифровывает:
     plaintext = decryptor.update(ciphertext)
     plaintext += decryptor.finalize()

  4. При finalize() проверяется Tag:
     - Если Tag верный → ✓ подлинность
     - Если Tag неверный → ✗ отбрасывание
     - Защита от подделки и модификации

  Результат: plaintext = "Привет, Боб!"
)
```